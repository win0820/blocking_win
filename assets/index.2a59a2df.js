import { d as e, r as t, o as a, c as i, w as n, K as s, a as o, b as c, e as d, f as l, l as r, g as h, h as D, i as m, j as u, k as g, F as b, m as f, V as S, z as x } from "/blocking_win/assets/vendor.e7b4ecd9.js"; !function () { const e = document.createElement("link").relList; if (!(e && e.supports && e.supports("modulepreload"))) { for (const e of document.querySelectorAll('link[rel="modulepreload"]')) t(e); new MutationObserver((e => { for (const a of e) if ("childList" === a.type) for (const e of a.addedNodes) "LINK" === e.tagName && "modulepreload" === e.rel && t(e) })).observe(document, { childList: !0, subtree: !0 }) } function t(e) { if (e.ep) return; e.ep = !0; const t = function (e) { const t = {}; return e.integrity && (t.integrity = e.integrity), e.referrerpolicy && (t.referrerPolicy = e.referrerpolicy), "use-credentials" === e.crossorigin ? t.credentials = "include" : "anonymous" === e.crossorigin ? t.credentials = "omit" : t.credentials = "same-origin", t }(e); fetch(e.href, t) } }(); var y = e({ name: "Home" }); y.render = function (e, c, d, l, r, h) { const D = t("router-view"); return a(), i(D, null, { default: n((({ Component: e }) => [(a(), i(s, null, [(a(), i(o(e)))], 1024))])), _: 1 }) }; class v { constructor(e) { this.context = e, this.oscillator = this.context.createOscillator(), this.gainNode = this.context.createGain(), this.State = !1 } init() { this.oscillator = this.context.createOscillator(), this.gainNode = this.context.createGain(), this.oscillator.connect(this.gainNode), this.gainNode.connect(this.context.destination) } play(e = 0) { this.oscillator.detune.value = -100 * e, this.State || (this.init(), this.gainNode.gain.setValueAtTime(.1, this.context.currentTime), this.oscillator.frequency.value = 2400, this.oscillator.start(), this.State = !0) } stop() { this.State && (this.gainNode.gain.exponentialRampToValueAtTime(.001, this.context.currentTime + 1), this.oscillator.stop(this.context.currentTime + 1), this.State = !1) } state() { return this.context.state } } const w = {}, p = {}, T = { flag: !1 }, I = {}, P = {}, L = {}, E = { value: !1 }; function A(e) { Object.values(e.itemsData).forEach((e => { e.isTouch = !1 })), Object.values(e.linesData).forEach((e => { e.isHover = !1, e.isTouch = !1 })) } function C(e, t) { const a = t.x, i = t.y, n = e.svgData.drawingContainer.createSVGPoint(); n.x = a, n.y = i; const s = e.svgData.drawingContainer.getScreenCTM(), o = n.matrixTransform(s.inverse()); return { x: Math.round(o.x), y: Math.round(o.y) } } function Y(e, t) { const a = function (e, t) { return Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2)) }(e, t), i = (e.x - t.x) / a, n = (e.y - t.y) / a; let s = 0; return n / i == -1 / 0 ? s = 270 : n / i == 1 / 0 ? s = 90 : i > 0 ? s = 180 - Math.atan(n / i) * (180 / 3.141596) : (s += n > 0 ? 0 : 360, s = -Math.atan(n / i) * (180 / 3.141596)), { vectorLength: a, unitVectorX: i, unitVectorY: n, angle: 360 - s } } function O(e) { const t = e.beSelectedItemData.id, a = e.itemsData[t].transform.rotationAngle; Array.from(Object.keys(e.pinsData[t])).forEach((i => { const n = Y({ x: 0, y: 0 }, { x: e.pinsData[t][i].relativeToItemCoordinate.cx, y: e.pinsData[t][i].relativeToItemCoordinate.cy }); e.pinsData[t][i].svgCoordinate.x = e.itemsData[t].transform.x + n.vectorLength * Math.cos((n.angle + a) * (3.14159 / 180)), e.pinsData[t][i].svgCoordinate.y = e.itemsData[t].transform.y + n.vectorLength * Math.sin((n.angle + a) * (3.14159 / 180)) })) } function X() { let e = Date.now(); return "undefined" != typeof performance && "function" == typeof performance.now && (e += performance.now()), "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (t => { const a = (e + 16 * Math.random()) % 16 | 0; return e = Math.floor(e / 16), ("x" === t ? a : 3 & a | 8).toString(16) })) } function M(e, t) { const a = t.mouseEvent, i = t.pinIndex, n = t.itemId; a.preventDefault(); const s = C(e, { x: a.clientX, y: a.clientY }); if ("mousedown" === a.type) { let t; A(e), e.beSelectedLineData.isTouch ? (e.linesData[e.beSelectedLineData.id].connectedPins[e.linesData[e.beSelectedLineData.id].connectedPins.length - 1] = e.pinsData[n][i].svgCoordinate, e.beSelectedLineData.isTouch = !1, t = e.linesData[e.beSelectedLineData.id].connectedPins, Object.keys(e.linesData).forEach((a => { a !== e.beSelectedLineData.id && (e.linesData[a][0] === t[0] && e.linesData[a][e.linesData[a].connectedPins.length - 1] === t[t.length - 1] || e.linesData[a][0] === t[t.length - 1] && e.linesData[a][e.linesData[a].connectedPins.length - 1] === t[0]) && delete e.linesData[a] }))) : (e.beSelectedLineData.id = X(), function (e, t, a) { e.linesData[e.beSelectedLineData.id] = { isHover: !1, isTouch: !1, connectedPins: [{ x: t, y: a - 60 }, { x: t, y: a - 60 }] } }(e, a.clientX, a.clientY), e.linesData[e.beSelectedLineData.id].connectedPins[0] = e.pinsData[n][i].svgCoordinate, e.linesData[e.beSelectedLineData.id].connectedPins[e.linesData[e.beSelectedLineData.id].connectedPins.length - 1].x = s.x, e.linesData[e.beSelectedLineData.id].connectedPins[e.linesData[e.beSelectedLineData.id].connectedPins.length - 1].y = s.y, e.beSelectedLineData.isTouch = !0) } else if ("mousemove" === a.type) { const t = e.linesData[e.beSelectedLineData.id].connectedPins; t[t.length - 1].x = s.x, t[t.length - 1].y = s.y } } function k(e, t) { const a = t.mouseEvent, i = t.itemId; a.stopPropagation(); const n = C(e, { x: a.clientX, y: a.clientY }); if ("mousedown" === a.type) { e.beSelectedItemData.isTouch = !0, A(e), e.itemsData[i].isTouch = !0, e.beSelectedItemData.id = i; const t = { x: e.itemsData[i].transform.x, y: e.itemsData[i].transform.y }; e.beSelectedItemData.deltaX = n.x - t.x, e.beSelectedItemData.deltaY = n.y - t.y } else "mousemove" === a.type && (e.itemsData[i].transform.x = n.x - e.beSelectedItemData.deltaX, e.itemsData[i].transform.y = n.y - e.beSelectedItemData.deltaY, O(e)) } function z(e) { const t = e.beAddedItemData.itemName, a = X(); e.beAddedItemData.id = a, e.beSelectedItemData.id = e.beAddedItemData.id, e.beSelectedItemData.deltaX = 10, e.beSelectedItemData.deltaY = 10, e.itemsData[a] = { itemName: t, transform: { x: 200, y: 30, rotationAngle: 0 }, isTouch: !0, parameters: Object.assign({}, p[t]), simulationParameters: {} }, function (e, t) { e.pinsData[e.beAddedItemData.id] = [], e.itemFindpinList[t].forEach((t => { e.pinsData[e.beAddedItemData.id].push({ svgCoordinate: { x: 0, y: 0 }, relativeToItemCoordinate: { cx: t.cx, cy: t.cy } }) })), O(e) }(e, t) } const j = { windowSize: { height: 0, width: 0, aspectRatio: 0 }, svgData: { x: 0, y: 0, width: 0, height: 0, isTouch: !1, drawingContainer: {} }, beSelectedPinData: { id: "", index: -1, isTouch: !1 }, beSelectedLineData: { id: "", isTouch: !1 }, beSelectedItemData: { deltaX: 0, deltaY: 0, id: "", isTouch: !1 }, beAddedItemData: { itemName: "", id: "", isTouch: !1 }, pinsData: {}, itemsData: {}, linesData: {}, isRunMicroControllers: !1, mouseCoordinate: { x: 0, y: 0 }, isOpenEditor: !1, itemFindpinList: {}, isMouseUpSvg: !0, test: {} }; const N = c({ modules: { drawing: { actions: {}, getters: {}, mutations: { initializeSvgData(e) { e.svgData.width = e.windowSize.width, e.svgData.height = e.windowSize.height }, setIsRunMicroControllersInfo(e, t) { e.isRunMicroControllers = t }, zoomSvgToFitWindow: function (e, t) { const a = t.getBBox(), i = e.windowSize.aspectRatio; let n = 0; 0 !== a.width && 0 !== a.width && (a.width / a.height > i ? (n = e.svgData.width / a.width, e.svgData.width = a.width, e.svgData.height = e.svgData.height / n, e.svgData.x = a.x, e.svgData.y = a.y + (a.height - e.svgData.height) / 2) : (n = e.svgData.height / a.height, e.svgData.height = a.height, e.svgData.y = a.y, e.svgData.width = e.svgData.width / n, e.svgData.x = a.x + (a.width - e.svgData.width) / 2)) }, mouseDownSvg: function (e, t) { if ("mousedown" === t.type) if (e.beSelectedLineData.isTouch) { const a = e.linesData[e.beSelectedLineData.id].connectedPins, i = C(e, { x: t.clientX, y: t.clientY }); i.x !== a[a.length - 2].x && (a[a.length - 1] = i, a.push({ x: i.x, y: i.y })) } else e.svgData.isTouch = !0, A(e), e.mouseCoordinate = { x: t.offsetX, y: t.offsetY } }, mouseUpSvg: function (e, t) { "mouseup" === t.type && (e.svgData.isTouch = !1, e.beSelectedItemData.isTouch = !1, e.isMouseUpSvg = !0) }, wheelSvg: function (e, t) { "mousewheel" !== t.type && "wheel" !== t.type || (t.deltaY < 0 ? (e.svgData.x -= .1 * t.offsetX * (e.svgData.width / e.windowSize.width), e.svgData.y -= .1 * t.offsetY * (e.svgData.height / e.windowSize.height), e.svgData.width *= 1.1, e.svgData.height *= 1.1) : (e.svgData.x += t.offsetX * (1 / 11) * (e.svgData.width / e.windowSize.width), e.svgData.y += t.offsetY * (1 / 11) * (e.svgData.height / e.windowSize.height), e.svgData.width /= 1.1, e.svgData.height /= 1.1)) }, mouseMoveSvg: function (e, t) { if ("mousemove" === t.type) if (!e.svgData.isTouch || e.beSelectedItemData.isTouch || e.beSelectedLineData.isTouch || e.beAddedItemData.isTouch || e.beSelectedPinData.isTouch) if (e.svgData.isTouch || !e.beSelectedItemData.isTouch || e.beSelectedLineData.isTouch || e.beAddedItemData.isTouch || e.beSelectedPinData.isTouch) if (e.svgData.isTouch || e.beSelectedItemData.isTouch || !e.beSelectedLineData.isTouch || e.beAddedItemData.isTouch || e.beSelectedPinData.isTouch) if (e.svgData.isTouch || e.beSelectedItemData.isTouch || e.beSelectedLineData.isTouch || !e.beAddedItemData.isTouch || e.beSelectedPinData.isTouch) { if (!e.svgData.isTouch && !e.beSelectedItemData.isTouch && !e.beSelectedLineData.isTouch && !e.beAddedItemData.isTouch && e.beSelectedPinData.isTouch) if (t.buttons) { const a = C(e, { x: t.clientX, y: t.clientY }); e.linesData[e.beSelectedPinData.id].connectedPins[e.beSelectedPinData.index].x = a.x, e.linesData[e.beSelectedPinData.id].connectedPins[e.beSelectedPinData.index].y = a.y } else e.beSelectedPinData.isTouch = !1, e.beSelectedPinData.id = "", e.beSelectedPinData.index = -1 } else t.buttons ? (-1 === Object.keys(e.itemsData).indexOf(e.beAddedItemData.id) ? z(e) : (e.beAddedItemData.isTouch = !1, e.beSelectedItemData.isTouch = !0), k(e, { mouseEvent: t, itemId: e.beSelectedItemData.id })) : e.beAddedItemData.isTouch = !1; else M(e, { mouseEvent: t, pinIndex: -1, itemId: e.beSelectedLineData.id }); else t.buttons ? k(e, { mouseEvent: t, itemId: e.beSelectedItemData.id }) : e.beSelectedItemData.isTouch = !1; else t.buttons ? (e.svgData.x += (e.mouseCoordinate.x - t.offsetX) * (e.svgData.width / e.windowSize.width), e.svgData.y += (e.mouseCoordinate.y - t.offsetY) * (e.svgData.height / e.windowSize.height), e.mouseCoordinate.x = t.offsetX, e.mouseCoordinate.y = t.offsetY) : e.svgData.isTouch = !1 }, checkKeyFunction: function (e, t) { if ("r" === t.key && (e.beSelectedItemData.isTouch || e.beAddedItemData.isTouch)) { e.itemsData[e.beSelectedItemData.id].transform.rotationAngle += 45; const t = { x: e.itemsData[e.beSelectedItemData.id].transform.x + e.beSelectedItemData.deltaX, y: e.itemsData[e.beSelectedItemData.id].transform.y + e.beSelectedItemData.deltaY }; e.beSelectedItemData.deltaX = 0 === e.beSelectedItemData.deltaX ? 1 : e.beSelectedItemData.deltaX, e.beSelectedItemData.deltaY = 0 === e.beSelectedItemData.deltaY ? 1 : e.beSelectedItemData.deltaY; const a = Y({ x: 0, y: 0 }, { x: e.beSelectedItemData.deltaX, y: e.beSelectedItemData.deltaY }); a.angle += 45, e.beSelectedItemData.deltaX = a.vectorLength * Math.cos(3.1415 / 180 * a.angle), e.beSelectedItemData.deltaY = a.vectorLength * Math.sin(3.1415 / 180 * a.angle), e.itemsData[e.beSelectedItemData.id].transform.x = t.x - e.beSelectedItemData.deltaX, e.itemsData[e.beSelectedItemData.id].transform.y = t.y - e.beSelectedItemData.deltaY, O(e) } if ("Escape" === t.key || "Delete" === t.key) if (e.beSelectedPinData.isTouch) e.linesData[e.beSelectedPinData.id].connectedPins.splice(e.beSelectedPinData.index, 1), e.beSelectedPinData.isTouch = !1, e.beSelectedPinData.id = "", e.beSelectedPinData.index = -1; else if (e.beSelectedLineData.isTouch) delete e.linesData[e.beSelectedLineData.id], e.beSelectedLineData.isTouch = !1, e.beSelectedLineData.id = ""; else if (!e.beSelectedPinData.isTouch && !e.beSelectedLineData.isTouch) { const t = function (e) { const t = {}; Object.keys(e.itemsData).forEach((a => { e.itemsData[a].isTouch && (t.id = a, t.isExist = !0) })), e.beSelectedPinData.isTouch || Object.keys(e.linesData).forEach((a => { const i = e.linesData[a]; (i.isHover || i.isTouch) && (t.id = a, t.isExist = !0) })); return t }(e); t.isExist && (-1 !== Object.keys(e.itemsData).indexOf(t.id) && (e.beSelectedItemData.isTouch = !1, -1 !== Object.keys(P).indexOf(t.id) && delete P[t.id], delete e.itemsData[t.id], function (e, t) { const a = e.pinsData, i = e.linesData; a[t].forEach((e => { const t = e.svgCoordinate; Object.keys(i).forEach((e => { t !== i[e].connectedPins[0] && t !== i[e].connectedPins[i[e].connectedPins.length - 1] || delete i[e] })) })), delete a[t] }(e, t.id), e.beSelectedItemData.id = ""), -1 !== Object.keys(e.linesData).indexOf(t.id) && delete e.linesData[t.id]) } }, touchPin: M, touchItem: k, getCurrentWindowSize: function (e) { e.windowSize.width = window.innerWidth, e.windowSize.height = window.innerHeight - 60, e.windowSize.aspectRatio = e.windowSize.width / e.windowSize.height }, addItem: z, closeAllItemAndLineTouch: A, dom2SvgCoordinate: C, changeTest(e, t) { e.test = t } }, state: j, namespaced: !0 } } }), _ = {}, R = function (e, t) { return t && 0 !== t.length ? Promise.all(t.map((e => { if ((e = `/${e}`) in _) return; _[e] = !0; const t = e.endsWith(".css"), a = t ? '[rel="stylesheet"]' : ""; if (document.querySelector(`link[href="${e}"]${a}`)) return; const i = document.createElement("link"); return i.rel = t ? "stylesheet" : "modulepreload", t || (i.as = "script", i.crossOrigin = ""), i.href = e, document.head.appendChild(i), t ? new Promise(((e, t) => { i.addEventListener("load", e), i.addEventListener("error", t) })) : void 0 }))).then((() => e())) : e() }, V = [{ path: "/", name: "Home", component: () => R((() => import("/blocking_win/assets/Home.f6b53768.js")), ["assets/Home.f6b53768.js", "assets/Home.fdca70bd.css", "assets/vendor.e7b4ecd9.js"]) }, { path: "/drawing", name: "Drawing", component: () => R((() => import("/blocking_win/assets/Drawing.b4393028.js")), ["assets/Drawing.b4393028.js", "assets/Drawing.1ae4019c.css", "assets/vendor.e7b4ecd9.js"]) }], H = d({ history: l("/technology/front-end/"), routes: V }); r.add({ faFacebook: h, faYoutube: D, faLine: m, faBars: u, faXmark: g }); f(y).use(N).use(H).use(S).use(x).component("font-awesome-icon", b).mount("#app"); export { v as S, T as a, E as b, p as c, C as d, w as e, j as f, I as i, P as m, L as p, N as s };
